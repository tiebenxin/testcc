package com.lensim.fingerchat.hexmeet.db;


import de.greenrobot.dao.DaoException;

// THIS CODE IS GENERATED BY greenDAO, DO NOT EDIT. Enable "keep" sections if you want to edit. 

/**
 * Entity mapped to table "MEETING_USER_".
 */
public class MeetingUser_ {

  private Long id;
  private Long meetingId;
  private Long userId;

  /**
   * Used to resolve relations
   */
  private transient DaoSession daoSession;

  /**
   * Used for active entity operations.
   */
  private transient MeetingUser_Dao myDao;

  private RestUser_ user;
  private Long user__resolvedKey;

  private RestMeeting_ meeting;
  private Long meeting__resolvedKey;


  public MeetingUser_() {
  }

  public MeetingUser_(Long id) {
    this.id = id;
  }

  public MeetingUser_(Long id, Long meetingId, Long userId) {
    this.id = id;
    this.meetingId = meetingId;
    this.userId = userId;
  }

  /**
   * called by internal mechanisms, do not call yourself.
   */
  public void __setDaoSession(DaoSession daoSession) {
    this.daoSession = daoSession;
    myDao = daoSession != null ? daoSession.getMeetingUser_Dao() : null;
  }

  public Long getId() {
    return id;
  }

  public void setId(Long id) {
    this.id = id;
  }

  public Long getMeetingId() {
    return meetingId;
  }

  public void setMeetingId(Long meetingId) {
    this.meetingId = meetingId;
  }

  public Long getUserId() {
    return userId;
  }

  public void setUserId(Long userId) {
    this.userId = userId;
  }

  /**
   * To-one relationship, resolved on first access.
   */
  public RestUser_ getUser() {
    Long __key = this.userId;
    if (user__resolvedKey == null || !user__resolvedKey.equals(__key)) {
      if (daoSession == null) {
        throw new DaoException("Entity is detached from DAO context");
      }
      RestUser_Dao targetDao = daoSession.getRestUser_Dao();
      RestUser_ userNew = targetDao.load(__key);
      synchronized (this) {
        user = userNew;
        user__resolvedKey = __key;
      }
    }
    return user;
  }

  public void setUser(RestUser_ user) {
    synchronized (this) {
      this.user = user;
      userId = user == null ? null : user.getId();
      user__resolvedKey = userId;
    }
  }

  /**
   * To-one relationship, resolved on first access.
   */
  public RestMeeting_ getMeeting() {
    Long __key = this.meetingId;
    if (meeting__resolvedKey == null || !meeting__resolvedKey.equals(__key)) {
      if (daoSession == null) {
        throw new DaoException("Entity is detached from DAO context");
      }
      RestMeeting_Dao targetDao = daoSession.getRestMeeting_Dao();
      RestMeeting_ meetingNew = targetDao.load(__key);
      synchronized (this) {
        meeting = meetingNew;
        meeting__resolvedKey = __key;
      }
    }
    return meeting;
  }

  public void setMeeting(RestMeeting_ meeting) {
    synchronized (this) {
      this.meeting = meeting;
      meetingId = meeting == null ? null : meeting.getId();
      meeting__resolvedKey = meetingId;
    }
  }

  /**
   * Convenient call for {@link AbstractDao#delete(Object)}. Entity must attached to an entity context.
   */
  public void delete() {
    if (myDao == null) {
      throw new DaoException("Entity is detached from DAO context");
    }
    myDao.delete(this);
  }

  /**
   * Convenient call for {@link AbstractDao#update(Object)}. Entity must attached to an entity context.
   */
  public void update() {
    if (myDao == null) {
      throw new DaoException("Entity is detached from DAO context");
    }
    myDao.update(this);
  }

  /**
   * Convenient call for {@link AbstractDao#refresh(Object)}. Entity must attached to an entity context.
   */
  public void refresh() {
    if (myDao == null) {
      throw new DaoException("Entity is detached from DAO context");
    }
    myDao.refresh(this);
  }

}
