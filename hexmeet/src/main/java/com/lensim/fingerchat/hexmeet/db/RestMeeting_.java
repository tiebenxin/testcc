package com.lensim.fingerchat.hexmeet.db;

import java.util.List;

import de.greenrobot.dao.DaoException;

// THIS CODE IS GENERATED BY greenDAO, DO NOT EDIT. Enable "keep" sections if you want to edit. 

/**
 * Entity mapped to table "REST_MEETING_".
 */
public class RestMeeting_ {

  private Long id;
  private String name;
  private Long startTime;
  private Long duration;
  private long applicantId;
  private Integer masterEndpointId;
  private String masterEndpointName;
  private String layout;
  private String status;
  private Boolean autoRedialing;
  private String confPassword;
  private Integer numericId;
  private Boolean confTemplate;
  private Boolean privateTemplate;
  private String statusInfo;
  private Integer groupId;
  private String groupName;
  private String confType;
  private String remarks;
  private Integer unitId;
  private String unitName;
  private Integer departmentId;
  private String departName;
  private String contact;
  private String contactPhone;
  private Integer maxBandwidth;
  private Boolean enableRecording;
  private Boolean messageOverlayEnabled;
  private String messageOverlayContent;
  private Integer messageOverlayDisplayDuration;
  private Integer messageOverlayTransparency;
  private String messageOverlaySpeed;
  private String messageOverlayColor;
  private String messageOverlayFontSize;
  private String messageOverlayPosition;
  private Long lastModifiedTime;

  /**
   * Used to resolve relations
   */
  private transient DaoSession daoSession;

  /**
   * Used for active entity operations.
   */
  private transient RestMeeting_Dao myDao;

  private RestUser_ applicant;
  private Long applicant__resolvedKey;

  private List<MeetingContact_> meetingContacts;
  private List<MeetingUser_> meetingUsers;
  private List<MeetingEndpoint_> meetingEndpoints;

  public RestMeeting_() {
  }

  public RestMeeting_(Long id) {
    this.id = id;
  }

  public RestMeeting_(Long id, String name, Long startTime, Long duration, long applicantId, Integer masterEndpointId, String masterEndpointName, String layout, String status, Boolean autoRedialing, String confPassword, Integer numericId, Boolean confTemplate, Boolean privateTemplate,
      String statusInfo, Integer groupId, String groupName, String confType, String remarks, Integer unitId, String unitName, Integer departmentId, String departName, String contact, String contactPhone, Integer maxBandwidth, Boolean enableRecording, Boolean messageOverlayEnabled,
      String messageOverlayContent, Integer messageOverlayDisplayDuration, Integer messageOverlayTransparency, String messageOverlaySpeed, String messageOverlayColor, String messageOverlayFontSize, String messageOverlayPosition, Long lastModifiedTime) {
    this.id = id;
    this.name = name;
    this.startTime = startTime;
    this.duration = duration;
    this.applicantId = applicantId;
    this.masterEndpointId = masterEndpointId;
    this.masterEndpointName = masterEndpointName;
    this.layout = layout;
    this.status = status;
    this.autoRedialing = autoRedialing;
    this.confPassword = confPassword;
    this.numericId = numericId;
    this.confTemplate = confTemplate;
    this.privateTemplate = privateTemplate;
    this.statusInfo = statusInfo;
    this.groupId = groupId;
    this.groupName = groupName;
    this.confType = confType;
    this.remarks = remarks;
    this.unitId = unitId;
    this.unitName = unitName;
    this.departmentId = departmentId;
    this.departName = departName;
    this.contact = contact;
    this.contactPhone = contactPhone;
    this.maxBandwidth = maxBandwidth;
    this.enableRecording = enableRecording;
    this.messageOverlayEnabled = messageOverlayEnabled;
    this.messageOverlayContent = messageOverlayContent;
    this.messageOverlayDisplayDuration = messageOverlayDisplayDuration;
    this.messageOverlayTransparency = messageOverlayTransparency;
    this.messageOverlaySpeed = messageOverlaySpeed;
    this.messageOverlayColor = messageOverlayColor;
    this.messageOverlayFontSize = messageOverlayFontSize;
    this.messageOverlayPosition = messageOverlayPosition;
    this.lastModifiedTime = lastModifiedTime;
  }

  /**
   * called by internal mechanisms, do not call yourself.
   */
  public void __setDaoSession(DaoSession daoSession) {
    this.daoSession = daoSession;
    myDao = daoSession != null ? daoSession.getRestMeeting_Dao() : null;
  }

  public Long getId() {
    return id;
  }

  public void setId(Long id) {
    this.id = id;
  }

  public String getName() {
    return name;
  }

  public void setName(String name) {
    this.name = name;
  }

  public Long getStartTime() {
    return startTime;
  }

  public void setStartTime(Long startTime) {
    this.startTime = startTime;
  }

  public Long getDuration() {
    return duration;
  }

  public void setDuration(Long duration) {
    this.duration = duration;
  }

  public long getApplicantId() {
    return applicantId;
  }

  public void setApplicantId(long applicantId) {
    this.applicantId = applicantId;
  }

  public Integer getMasterEndpointId() {
    return masterEndpointId;
  }

  public void setMasterEndpointId(Integer masterEndpointId) {
    this.masterEndpointId = masterEndpointId;
  }

  public String getMasterEndpointName() {
    return masterEndpointName;
  }

  public void setMasterEndpointName(String masterEndpointName) {
    this.masterEndpointName = masterEndpointName;
  }

  public String getLayout() {
    return layout;
  }

  public void setLayout(String layout) {
    this.layout = layout;
  }

  public String getStatus() {
    return status;
  }

  public void setStatus(String status) {
    this.status = status;
  }

  public Boolean getAutoRedialing() {
    return autoRedialing;
  }

  public void setAutoRedialing(Boolean autoRedialing) {
    this.autoRedialing = autoRedialing;
  }

  public String getConfPassword() {
    return confPassword;
  }

  public void setConfPassword(String confPassword) {
    this.confPassword = confPassword;
  }

  public Integer getNumericId() {
    return numericId;
  }

  public void setNumericId(Integer numericId) {
    this.numericId = numericId;
  }

  public Boolean getConfTemplate() {
    return confTemplate;
  }

  public void setConfTemplate(Boolean confTemplate) {
    this.confTemplate = confTemplate;
  }

  public Boolean getPrivateTemplate() {
    return privateTemplate;
  }

  public void setPrivateTemplate(Boolean privateTemplate) {
    this.privateTemplate = privateTemplate;
  }

  public String getStatusInfo() {
    return statusInfo;
  }

  public void setStatusInfo(String statusInfo) {
    this.statusInfo = statusInfo;
  }

  public Integer getGroupId() {
    return groupId;
  }

  public void setGroupId(Integer groupId) {
    this.groupId = groupId;
  }

  public String getGroupName() {
    return groupName;
  }

  public void setGroupName(String groupName) {
    this.groupName = groupName;
  }

  public String getConfType() {
    return confType;
  }

  public void setConfType(String confType) {
    this.confType = confType;
  }

  public String getRemarks() {
    return remarks;
  }

  public void setRemarks(String remarks) {
    this.remarks = remarks;
  }

  public Integer getUnitId() {
    return unitId;
  }

  public void setUnitId(Integer unitId) {
    this.unitId = unitId;
  }

  public String getUnitName() {
    return unitName;
  }

  public void setUnitName(String unitName) {
    this.unitName = unitName;
  }

  public Integer getDepartmentId() {
    return departmentId;
  }

  public void setDepartmentId(Integer departmentId) {
    this.departmentId = departmentId;
  }

  public String getDepartName() {
    return departName;
  }

  public void setDepartName(String departName) {
    this.departName = departName;
  }

  public String getContact() {
    return contact;
  }

  public void setContact(String contact) {
    this.contact = contact;
  }

  public String getContactPhone() {
    return contactPhone;
  }

  public void setContactPhone(String contactPhone) {
    this.contactPhone = contactPhone;
  }

  public Integer getMaxBandwidth() {
    return maxBandwidth;
  }

  public void setMaxBandwidth(Integer maxBandwidth) {
    this.maxBandwidth = maxBandwidth;
  }

  public Boolean getEnableRecording() {
    return enableRecording;
  }

  public void setEnableRecording(Boolean enableRecording) {
    this.enableRecording = enableRecording;
  }

  public Boolean getMessageOverlayEnabled() {
    return messageOverlayEnabled;
  }

  public void setMessageOverlayEnabled(Boolean messageOverlayEnabled) {
    this.messageOverlayEnabled = messageOverlayEnabled;
  }

  public String getMessageOverlayContent() {
    return messageOverlayContent;
  }

  public void setMessageOverlayContent(String messageOverlayContent) {
    this.messageOverlayContent = messageOverlayContent;
  }

  public Integer getMessageOverlayDisplayDuration() {
    return messageOverlayDisplayDuration;
  }

  public void setMessageOverlayDisplayDuration(Integer messageOverlayDisplayDuration) {
    this.messageOverlayDisplayDuration = messageOverlayDisplayDuration;
  }

  public Integer getMessageOverlayTransparency() {
    return messageOverlayTransparency;
  }

  public void setMessageOverlayTransparency(Integer messageOverlayTransparency) {
    this.messageOverlayTransparency = messageOverlayTransparency;
  }

  public String getMessageOverlaySpeed() {
    return messageOverlaySpeed;
  }

  public void setMessageOverlaySpeed(String messageOverlaySpeed) {
    this.messageOverlaySpeed = messageOverlaySpeed;
  }

  public String getMessageOverlayColor() {
    return messageOverlayColor;
  }

  public void setMessageOverlayColor(String messageOverlayColor) {
    this.messageOverlayColor = messageOverlayColor;
  }

  public String getMessageOverlayFontSize() {
    return messageOverlayFontSize;
  }

  public void setMessageOverlayFontSize(String messageOverlayFontSize) {
    this.messageOverlayFontSize = messageOverlayFontSize;
  }

  public String getMessageOverlayPosition() {
    return messageOverlayPosition;
  }

  public void setMessageOverlayPosition(String messageOverlayPosition) {
    this.messageOverlayPosition = messageOverlayPosition;
  }

  public Long getLastModifiedTime() {
    return lastModifiedTime;
  }

  public void setLastModifiedTime(Long lastModifiedTime) {
    this.lastModifiedTime = lastModifiedTime;
  }

  /**
   * To-one relationship, resolved on first access.
   */
  public RestUser_ getApplicant() {
    long __key = this.applicantId;
    if (applicant__resolvedKey == null || !applicant__resolvedKey.equals(__key)) {
      if (daoSession == null) {
        throw new DaoException("Entity is detached from DAO context");
      }
      RestUser_Dao targetDao = daoSession.getRestUser_Dao();
      RestUser_ applicantNew = targetDao.load(__key);
      synchronized (this) {
        applicant = applicantNew;
        applicant__resolvedKey = __key;
      }
    }
    return applicant;
  }

  public void setApplicant(RestUser_ applicant) {
    if (applicant == null) {
      throw new DaoException("To-one property 'applicantId' has not-null constraint; cannot set to-one to null");
    }
    synchronized (this) {
      this.applicant = applicant;
      applicantId = applicant.getId();
      applicant__resolvedKey = applicantId;
    }
  }

  /**
   * To-many relationship, resolved on first access (and after reset). Changes to to-many relations are not persisted, make changes to the target entity.
   */
  public List<MeetingContact_> getMeetingContacts() {
    if (meetingContacts == null) {
      if (daoSession == null) {
        throw new DaoException("Entity is detached from DAO context");
      }
      MeetingContact_Dao targetDao = daoSession.getMeetingContact_Dao();
      List<MeetingContact_> meetingContactsNew = targetDao._queryRestMeeting__MeetingContacts(id);
      synchronized (this) {
        if (meetingContacts == null) {
          meetingContacts = meetingContactsNew;
        }
      }
    }
    return meetingContacts;
  }

  /**
   * Resets a to-many relationship, making the next get call to query for a fresh result.
   */
  public synchronized void resetMeetingContacts() {
    meetingContacts = null;
  }

  /**
   * To-many relationship, resolved on first access (and after reset). Changes to to-many relations are not persisted, make changes to the target entity.
   */
  public List<MeetingUser_> getMeetingUsers() {
    if (meetingUsers == null) {
      if (daoSession == null) {
        throw new DaoException("Entity is detached from DAO context");
      }
      MeetingUser_Dao targetDao = daoSession.getMeetingUser_Dao();
      List<MeetingUser_> meetingUsersNew = targetDao._queryRestMeeting__MeetingUsers(id);
      synchronized (this) {
        if (meetingUsers == null) {
          meetingUsers = meetingUsersNew;
        }
      }
    }
    return meetingUsers;
  }

  /**
   * Resets a to-many relationship, making the next get call to query for a fresh result.
   */
  public synchronized void resetMeetingUsers() {
    meetingUsers = null;
  }

  /**
   * To-many relationship, resolved on first access (and after reset). Changes to to-many relations are not persisted, make changes to the target entity.
   */
  public List<MeetingEndpoint_> getMeetingEndpoints() {
    if (meetingEndpoints == null) {
      if (daoSession == null) {
        throw new DaoException("Entity is detached from DAO context");
      }
      MeetingEndpoint_Dao targetDao = daoSession.getMeetingEndpoint_Dao();
      List<MeetingEndpoint_> meetingEndpointsNew = targetDao._queryRestMeeting__MeetingEndpoints(id);
      synchronized (this) {
        if (meetingEndpoints == null) {
          meetingEndpoints = meetingEndpointsNew;
        }
      }
    }
    return meetingEndpoints;
  }

  /**
   * Resets a to-many relationship, making the next get call to query for a fresh result.
   */
  public synchronized void resetMeetingEndpoints() {
    meetingEndpoints = null;
  }

  /**
   * Convenient call for {@link AbstractDao#delete(Object)}. Entity must attached to an entity context.
   */
  public void delete() {
    if (myDao == null) {
      throw new DaoException("Entity is detached from DAO context");
    }
    myDao.delete(this);
  }

  /**
   * Convenient call for {@link AbstractDao#update(Object)}. Entity must attached to an entity context.
   */
  public void update() {
    if (myDao == null) {
      throw new DaoException("Entity is detached from DAO context");
    }
    myDao.update(this);
  }

  /**
   * Convenient call for {@link AbstractDao#refresh(Object)}. Entity must attached to an entity context.
   */
  public void refresh() {
    if (myDao == null) {
      throw new DaoException("Entity is detached from DAO context");
    }
    myDao.refresh(this);
  }

}
